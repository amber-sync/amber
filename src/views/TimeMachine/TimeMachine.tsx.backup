/**
 * TimeMachine - Unified Backup Time Travel Experience
 *
 * Replaces TimeExplorer, TimelineView, and JobDetail with a single
 * immersive interface centered on timeline navigation.
 *
 * @see docs/UNIFIED_TIME_MACHINE_DESIGN.md
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useApp } from '../../context/AppContext';
import { api } from '../../api';
import { Snapshot, SyncJob, LogEntry, RsyncProgressData } from '../../types';
import { Icons } from '../../components/IconComponents';

// Components
import { TimeMachineHeader } from './components/TimeMachineHeader';
import { TimelineRuler } from './components/TimelineRuler';
import { SnapshotFocus } from './components/SnapshotFocus';
import { LiveActivityBar } from './components/LiveActivityBar';
import { FileExplorerOverlay } from './components/FileExplorerOverlay';
import { RestoreOverlay } from './components/RestoreOverlay';
import { AnalyticsOverlay } from './components/AnalyticsOverlay';
import { TerminalOverlay } from './components/TerminalOverlay';
import { EmptyState } from './components/EmptyState';
import { SlidePanel } from '../../components/explorer/panels/SlidePanel';
import { EditJobPanel } from '../../components/explorer/panels/EditJobPanel';

// Styles
import './timemachine.css';

export type OverlayType = 'files' | 'restore' | 'analytics' | 'terminal' | null;
export type DateFilter = 'all' | '7days' | '30days' | '90days' | 'year';

export interface TimeMachineSnapshot extends Snapshot {
  jobId: string;
  jobName: string;
}

interface TimeMachineProps {
  /** Pre-selected job ID (from navigation) */
  initialJobId?: string;
  /** Live sync state from parent context */
  isRunning?: boolean;
  progress?: RsyncProgressData | null;
  logs?: LogEntry[];
}

export function TimeMachine({
  initialJobId,
  isRunning = false,
  progress = null,
  logs = [],
}: TimeMachineProps) {
  const { jobs, activeJobId, setActiveJobId, setView, runSync, stopSync, persistJob, deleteJob } =
    useApp();

  // Current job
  const [currentJobId, setCurrentJobId] = useState<string | null>(
    initialJobId || activeJobId || null
  );
  const currentJob = useMemo(
    () => jobs.find((j: SyncJob) => j.id === currentJobId) || null,
    [jobs, currentJobId]
  );

  // Snapshots for current job
  const [snapshots, setSnapshots] = useState<TimeMachineSnapshot[]>([]);
  const [loading, setLoading] = useState(true);

  // Date filter state (TIM-151)
  const [dateFilter, setDateFilter] = useState<DateFilter>('all');

  // Timeline state
  const [selectedTimestamp, setSelectedTimestamp] = useState<number | null>(null);

  // Filtered snapshots based on date range (TIM-151)
  const filteredSnapshots = useMemo(() => {
    if (dateFilter === 'all' || !snapshots.length) return snapshots;

    const now = Date.now();
    const cutoffs: Record<DateFilter, number> = {
      'all': 0,
      '7days': 7 * 24 * 60 * 60 * 1000,
      '30days': 30 * 24 * 60 * 60 * 1000,
      '90days': 90 * 24 * 60 * 60 * 1000,
      'year': 365 * 24 * 60 * 60 * 1000,
    };

    const cutoff = now - cutoffs[dateFilter];
    return snapshots.filter(s => s.timestamp >= cutoff);
  }, [snapshots, dateFilter]);

  const selectedSnapshot = useMemo(
    () => filteredSnapshots.find(s => s.timestamp === selectedTimestamp) || null,
    [filteredSnapshots, selectedTimestamp]
  );

  // Overlay state
  const [activeOverlay, setActiveOverlay] = useState<OverlayType>(null);
  const [fileBrowserPath, setFileBrowserPath] = useState<string | null>(null);
  const [showEditPanel, setShowEditPanel] = useState(false);

  // Load snapshots when job changes
  useEffect(() => {
    if (!currentJob) {
      setSnapshots([]);
      setLoading(false);
      return;
    }

    const loadSnapshots = async () => {
      setLoading(true);
      try {
        const snapshotList = await api.listSnapshots(currentJob.id, currentJob.destPath);
        const enriched: TimeMachineSnapshot[] = snapshotList.map(s => ({
          ...s,
          jobId: currentJob.id,
          jobName: currentJob.name,
        }));
        setSnapshots(enriched);

        // Auto-select latest snapshot if none selected
        if (enriched.length > 0 && !selectedTimestamp) {
          setSelectedTimestamp(enriched[enriched.length - 1].timestamp);
        }
      } catch (error) {
        console.error('Failed to load snapshots:', error);
        setSnapshots([]);
      } finally {
        setLoading(false);
      }
    };

    loadSnapshots();
  }, [currentJob]);

  // Sync active job with context
  useEffect(() => {
    if (currentJobId && currentJobId !== activeJobId) {
      setActiveJobId(currentJobId);
    }
  }, [currentJobId, activeJobId, setActiveJobId]);

  // Keyboard navigation (TIM-149)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't handle if user is typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      // Don't handle if any overlay is open (except Escape)
      if (activeOverlay && e.key !== 'Escape') {
        return;
      }

      // Don't handle if edit panel is open (except Escape)
      if (showEditPanel && e.key !== 'Escape') {
        return;
      }

      const currentIndex = filteredSnapshots.findIndex(s => s.timestamp === selectedTimestamp);

      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          // Navigate to previous snapshot
          if (filteredSnapshots.length > 0 && currentIndex > 0) {
            setSelectedTimestamp(filteredSnapshots[currentIndex - 1].timestamp);
          }
          break;
        case 'ArrowRight':
          e.preventDefault();
          // Navigate to next snapshot
          if (filteredSnapshots.length > 0 && currentIndex < filteredSnapshots.length - 1) {
            setSelectedTimestamp(filteredSnapshots[currentIndex + 1].timestamp);
          }
          break;
        case 'Escape':
          e.preventDefault();
          // Close any open panel/overlay
          if (showEditPanel) {
            setShowEditPanel(false);
          } else if (activeOverlay) {
            setActiveOverlay(null);
            setFileBrowserPath(null);
          }
          break;
        case 'Enter':
          e.preventDefault();
          // Open file explorer for current snapshot
          if (selectedSnapshot && !activeOverlay && !showEditPanel) {
            handleBrowseFiles();
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [filteredSnapshots, selectedTimestamp, showEditPanel, activeOverlay, selectedSnapshot, handleBrowseFiles]);

  // Handlers
  const handleJobSwitch = useCallback((jobId: string) => {
    setCurrentJobId(jobId);
    setSelectedTimestamp(null);
    setActiveOverlay(null);
    setDateFilter('all'); // Reset filter when switching jobs
  }, []);

  const handleBack = useCallback(() => {
    setView('DASHBOARD');
  }, [setView]);

  const handleSelectSnapshot = useCallback((timestamp: number) => {
    setSelectedTimestamp(timestamp);
  }, []);

  const handleBrowseFiles = useCallback(() => {
    if (selectedSnapshot?.path) {
      setFileBrowserPath(selectedSnapshot.path);
      setActiveOverlay('files');
    }
  }, [selectedSnapshot]);

  const handleRestore = useCallback(() => {
    setActiveOverlay('restore');
  }, []);

  const handleViewAnalytics = useCallback(() => {
    setActiveOverlay('analytics');
  }, []);

  const handleExpandTerminal = useCallback(() => {
    setActiveOverlay('terminal');
  }, []);

  const handleCloseOverlay = useCallback(() => {
    setActiveOverlay(null);
    setFileBrowserPath(null);
  }, []);

  const handleRunBackup = useCallback(() => {
    if (currentJobId) {
      runSync(currentJobId);
    }
  }, [currentJobId, runSync]);

  const handleStopBackup = useCallback(() => {
    if (currentJobId) {
      stopSync(currentJobId);
    }
  }, [currentJobId, stopSync]);

  const handleEditJob = useCallback(() => {
    if (currentJobId) {
      setShowEditPanel(true);
    }
  }, [currentJobId]);

  const handleNewJob = useCallback(() => {
    setActiveJobId(null);
    setView('JOB_EDITOR');
  }, [setActiveJobId, setView]);

  const handleSaveJobEdit = useCallback(
    async (updatedJob: SyncJob) => {
      try {
        await persistJob(updatedJob);
        setShowEditPanel(false);
      } catch (error) {
        console.error('Failed to save job:', error);
      }
    },
    [persistJob]
  );

  const handleDeleteJob = useCallback(async () => {
    if (!currentJobId) return;
    try {
      await deleteJob(currentJobId);
      setShowEditPanel(false);
      // Navigate back to dashboard after deleting current job
      setView('DASHBOARD');
    } catch (error) {
      console.error('Failed to delete job:', error);
    }
  }, [currentJobId, deleteJob, setView]);

  // Calculate time range from filtered snapshots (TIM-151)
  const timeRange = useMemo(() => {
    if (filteredSnapshots.length === 0) {
      const now = Date.now();
      return { start: now - 30 * 24 * 60 * 60 * 1000, end: now };
    }
    const timestamps = filteredSnapshots.map(s => s.timestamp);
    return {
      start: Math.min(...timestamps),
      end: Date.now(),
    };
  }, [filteredSnapshots]);

  // No job selected state
  if (!currentJob) {
    return (
      <div className="tm-container flex flex-col h-screen">
        <TimeMachineHeader
          job={null}
          jobs={jobs}
          isRunning={false}
          progress={null}
          onJobSwitch={handleJobSwitch}
          onBack={handleBack}
          onRunBackup={handleRunBackup}
          onStopBackup={handleStopBackup}
          onEditJob={handleEditJob}
          onNewJob={handleNewJob}
        />
        <EmptyState type="no-job" onAction={handleBack} actionLabel="Go to Dashboard" />
      </div>
    );
  }

  // No snapshots state
  if (!loading && snapshots.length === 0) {
    return (
      <div className="tm-container flex flex-col h-screen">
        <TimeMachineHeader
          job={currentJob}
          jobs={jobs}
          isRunning={isRunning}
          progress={progress}
          onJobSwitch={handleJobSwitch}
          onBack={handleBack}
          onRunBackup={handleRunBackup}
          onStopBackup={handleStopBackup}
          onEditJob={handleEditJob}
          onNewJob={handleNewJob}
        />
        <EmptyState type="no-snapshots" onAction={handleRunBackup} actionLabel="Run First Backup" />
        <LiveActivityBar
          isRunning={isRunning}
          progress={progress}
          logs={logs}
          onExpand={handleExpandTerminal}
        />
      </div>
    );
  }

  return (
    <div className="tm-container flex flex-col h-screen">
      {/* Header with job switcher and controls (TIM-138, TIM-151) */}
      <TimeMachineHeader
        job={currentJob}
        jobs={jobs}
        isRunning={isRunning}
        progress={progress}
        onJobSwitch={handleJobSwitch}
        onBack={handleBack}
        onRunBackup={handleRunBackup}
        onStopBackup={handleStopBackup}
        onEditJob={handleEditJob}
        onNewJob={handleNewJob}
        dateFilter={dateFilter}
        onDateFilterChange={setDateFilter}
        snapshotCount={filteredSnapshots.length}
        totalSnapshotCount={snapshots.length}
      />

      {/* Timeline - THE primary navigation (TIM-151: uses filtered snapshots) */}
      <TimelineRuler
        snapshots={filteredSnapshots}
        selectedTimestamp={selectedTimestamp}
        timeRange={timeRange}
        onSelectSnapshot={handleSelectSnapshot}
        loading={loading}
      />

      {/* Snapshot Focus - Central content */}
      <SnapshotFocus
        snapshot={selectedSnapshot}
        job={currentJob}
        onBrowseFiles={handleBrowseFiles}
        onRestore={handleRestore}
        onViewAnalytics={handleViewAnalytics}
        onRunBackup={handleRunBackup}
        isRunning={isRunning}
      />

      {/* Live Activity Bar - Fixed at bottom during sync */}
      <LiveActivityBar
        isRunning={isRunning}
        progress={progress}
        logs={logs}
        onExpand={handleExpandTerminal}
      />

      {/* Overlays */}
      <FileExplorerOverlay
        isOpen={activeOverlay === 'files'}
        path={fileBrowserPath}
        jobId={currentJobId}
        snapshotTimestamp={selectedTimestamp}
        destPath={currentJob.destPath}
        onClose={handleCloseOverlay}
      />

      <RestoreOverlay
        isOpen={activeOverlay === 'restore'}
        job={currentJob}
        snapshot={selectedSnapshot}
        snapshots={filteredSnapshots}
        onClose={handleCloseOverlay}
      />

      <AnalyticsOverlay
        isOpen={activeOverlay === 'analytics'}
        job={currentJob}
        snapshot={selectedSnapshot}
        onClose={handleCloseOverlay}
      />

      <TerminalOverlay
        isOpen={activeOverlay === 'terminal'}
        logs={logs}
        progress={progress}
        isRunning={isRunning}
        onClose={handleCloseOverlay}
        onStop={handleStopBackup}
      />

      {/* Edit Job Panel */}
      <SlidePanel
        isOpen={showEditPanel}
        onClose={() => setShowEditPanel(false)}
        title="Edit Job Settings"
        width="lg"
      >
        {currentJob && (
          <EditJobPanel
            job={currentJob}
            onSave={handleSaveJobEdit}
            onDelete={handleDeleteJob}
            onClose={() => setShowEditPanel(false)}
          />
        )}
      </SlidePanel>
    </div>
  );
}

export default TimeMachine;
